<!DOCTYPE html>
<html lang="en">
<head>
{% include 'head.html' %}
</head>
<body>

<div class="container">
      <div class="box">
          <h2 class="text-center">
            About YouTubeSWEg
          </h2>        
      </div>

      <div class="box">
        <div class="col-lg-12">
          <p>
            YouTubeSWEg is a state of the art static web app that provides a compilation of YouTube content information easily accessible through our GUI. This website is intended for users that are interested in finding insights and connections between media and content that they consume on a daily basis.
          </p>
        </div>
      </div>
      <br />
      <div class="box">
        <div class="box">
          <h2 class="text-center">
            The SWEventeen team
          </h2>
        </div>
<div class="album text-muted">
      <div class="container">

        <div class="row">
          <div class="card">
            <img src="{{ url_for('static', filename='prad.jpg') }}">
            <div class="box">
              <h1>
                Prad Pagadala
              </h1>
            </div>
            <p class="card-text">

              <p>Senior CS student. Software Engineer. Interested in SWE and YouTube but most interested in YouTubeSWEg.</p>
              <p><b>major responsibilities: </b> Slack management, Project management, React Magic, Documentation</p>
              <p><b>no. commits: </b>10</p>
              <p><b>no. issues: </b>10</p>
              <p><b>no. unit tests: </b>2</p>

            </p>
          </div>
          <div class="card">
            <img src="{{ url_for('static', filename='hamza.jpg') }}">
            <div class="box">
              <h1>
                Hamza M.
              </h1>
            </div>            
            <p class="card-text">
              
             <p>I'm a computer science junior at UT Austin. I'm a fan of Steph Curry, and I like cheesecake.</p>
             <p><b>major responsibilities: </b>setup GCP, designed backend, RESTful API development, frontend implementation, workflow integrity, overall team morale</p>
             <p><b>no. commits: </b>22</p>
             <p><b>no. issues: </b>5</p>
             <p><b>no. unit tests: </b>3</p>

            </p>
          </div>
          <div class="card">
            <img src="{{ url_for('static', filename='vinay.jpg') }}">
            <div class="box">
              <h1>
                Vinay Rayini
              </h1>
            </div>            
            <p class="card-text">
              <p>I'm a junior studying Computer Science at UT Austin. I hope this website gets me a job at Facebook.</p>
              <p><b>major responsibilities: </b>backend model/database design, RESTful API documentation, frontend HTML/CSS and Flask, pair programming</p>
              <p><b>no. commits: </b>19</p>
              <p><b>no. issues: </b>4</p>
              <p><b>no. unit tests: </b>2</p>
            </p>
          </div>

          <div class="card">
            <img src="{{ url_for('static', filename='zal.jpg') }}">
            <div class="box">
              <h1>
                Zal Daroga
              </h1>
            </div>            
            <p class="card-text">
              <p>I'm a computer science junior at UT Austin. I'm also a fan of James Harden, and chicken wings are my favorite food.</p>
               <p><b>major responsibilities: </b>frontend HTML, Flask, pair programmer, UML design, report content</p>
               <p><b>no. commits: </b>25</p>
               <p><b>no. issues: </b>7</p>
               <p><b>no. unit tests: </b>3</p>
            </p>
          </div>
          <div class="card">
            <img src="{{ url_for('static', filename='nicole.png') }}">
            <div class="box">
              <h1>
                Nicole V.
              </h1>
            </div>            
            <p class="card-text">
              <p>Computer Science major at UT Austin, planning on getting the Business Foundations Certificate. I do competitive club gymnastics at UT and will be interning at Facebook over the summer. </p>
              <p><b>major responsibilities: </b>frontend design, report structure, report content, creating UML design, pair programming</p>
              <p><b>no. commits: </b>20</p>
               <p><b>no. issues: </b>10</p>
               <p><b>no. unit tests: </b>2</p>
            </p>
          </div>
          <div class="card">
            <img src="{{ url_for('static', filename='shay.jpg') }}">
            <div class="box">
              <h1>
                Shaayaan Sayed
              </h1>
            </div>            
            <p class="card-text">
              <p>I'm a computer science junior at UT Austin. I'm a fan of James Harden, and I like sushi.</p>
              <p><b>major responsibilities: </b>report structure, report content, creating UML design, pair programming</p>
              <p><b>no. commits: </b>13</p>
              <p><b>no. issues: </b>9</p>
              <p><b>no. unit tests: </b>3</p>
            </p>
          </div>
        </div>

      </div>
    </div>

    <div class="box">
      <h2 class="text-center">
        Statistics
              <h4 class="text-center">
                <b>total no. commits: </b>109
              </h4>

              <h4 class="text-center">
                <b>total no. issues: </b> 45       
              </h4>

              <h4 class="text-center">
                <b>total no. unit tests: </b> 15
              </h4>

              <h4 class="text-center">
                <b>Apiary API: </b><a href="http://docs.youtubesweg.apiary.io/">http://docs.youtubesweg.apiary.io/</a>
              </h4>

              <h4 class="text-center">
                <b>GitHub issue tracker: </b><a href="https://github.com/rayiniv/YouTubeSWEg/issues">https://github.com/rayiniv/YouTubeSWEg/issues</a> 
              </h4>

              <h4 class="text-center">
                <b>GitHub repo: </b><a href="https://github.com/rayiniv/YouTubeSWEg">https://github.com/rayiniv/YouTubeSWEg</a>
              </h4>

              <h4 class="text-center">
                <b>Unit tests: </b><a href="/unit_tests">Run</a>
              </h4>

              <h4 class="text-center">
                <b>Presentation: </b><a href="https://docs.google.com/presentation/d/1h8qL43j9W4DnZqLRsGgsiaPswnpOpwwpYCUp31MPADU/edit?usp=sharing">Google Slides</a>
              </h4>              

      </h2>
    </div>

    <div class="box">
      <h2 class="text-center">
        Group 8: Eklogi.me Visualization
        <h4 class="text-center">
            <a href="/visualization">Run Visualization</a>
        </h4>
      </h2>
    </div>

    <div class="box">
      <h2 class="text-center">
        Data
        <h4 class="text-center">
          <p>
          <b>YouTube API: </b><a href="https://developers.google.com/youtube/v3/docs/">https://developers.google.com/youtube/v3/docs/</a>
        </p>
          used to scrape information regarding videos, channels, playlists, and categories

        </h4>      
      </h2>
    </div>

    <div class="box">
      <h2 class="text-center">
        Tools

        <h4 class="text-center">
          <b>Bootstrap: </b> front-end framework for website design

        </h4>
        <h4 class="text-center">
          <b>Google Cloud Platform: </b> cloud hosting for website

        </h4>
        <h4 class="text-center">
          <b>Flask: </b> web framework to route requests and render pages

        </h4>
        <h4 class="text-center">
          <b>Jinja2: </b> dynamically create HTML files by using common templates

        </h4>   
        <h4 class="text-center">
          <b>SqlAlchemy: </b> used to design backend models

        </h4>  
        <h4 class="text-center">
          <b>Apiary: </b> used to design a RESTful API for website

        </h4>                           
    </div>



<p><a href="#Introduction">Introduction</a></p>
  <p style="padding-left: 1.8em"><a href="#UseCase">Use Case</a></p>
<p><a href="#Frontend">Frontend</a></p>
  <p style="padding-left: 1.8em"><a href="#ContentStructure">Content Structure</a></p>
  <p style="padding-left: 1.8em"><a href="#WebsiteDesign">Website Design</a></p>
<p><a href="#Backend">Backend</a></p>
  <p style="padding-left: 1.8em"><a href="#YouTubeDataAPI">YouTube Data API</a></p>
  <p style="padding-left: 1.8em"><a href="#GCP">GCP</a></p>

    <p style="padding-left: 3.6em"><a href="#InstallingTheGoogleCloudSDK">Installing The Google Cloud SDK</a></p>
    <p style="padding-left: 3.6em"><a href="#DeployingYourApplication">Deploying Your Application</a></p>
    <p style="padding-left: 3.6em"><a href="#DeployingYourApplicationLocally">Deploying Your Application Locally</a></p>
    <p style="padding-left: 3.6em"><a href="#ViewingYourApplication">Viewing Your Application</a></p>
    <p style="padding-left: 3.6em"><a href="#PostgreSQLOnGCE">Setting up PostGreSQL</a></p>
  <p style="padding-left: 1.8em"><a href="#Flask/Jinja2">Flask/Jinja2</a></p>
  <p style="padding-left: 1.8em"><a href="#SQLAlchemy">SQLAlchemy</a></p>
<p><a href="#Testing">Testing</a></p>
  <p style="padding-left: 1.8em"><a href="#ContinuousIntegration">Continuous Integration</a></p>
  <p style="padding-left: 1.8em"><a href="#UnitTests">Unit Tests</a></p>
<p><a href="#ApplicationProgrammingInterface(API)">Application Programming Interface (API)</a></p>
<p><a href="#UMLDiagram">UML Diagram</a></p>
<p><a href="#Search Bar">Search Bar</a></p>
<p><a href="#PlanITPoker">PlanITPoker</a></p>
<p><a href="#Visualization">Visualization</a></p>
</p>



<br />
<br /><br />
<br /><br />
<br />
<a name="Introduction"></a>
<h1>Introduction</h1>
<p>Group name: SWEventeen</p>
<p>Group members: Prad Pagadala, Vinay Rayini, Hamza Muhammad, Zal Daroga, Nicole Voulgaropoulos, Shaayaan Sayed</p>
 
<p>YouTubeSWEg is a state of the art static web app that provides a compilation of YouTube content information easily accessible through our GUI. The goal of the project is to act as an hub for relational information that is usually only accessible through the API. This report outlines the design choices and implementation details involved in creating this application.</p

<a name="UseCase"></a>
<h2>Use Case</h2>

<p>YouTubeSWEg is intended to provide easy access to relational information regarding YouTube videos, channels, category, and playlists. These 4 models are linked together using various relationships to convey their nature. This is clearly expressed in our UML diagram. By utilizing the website, or provided API, users can easily find insights and connections between media and content that they consume on a daily basis.</p>
<br />
<br />
<a name="Frontend"></a>
<h1>Frontend</h1>

<a name="ContentStructure"></a>
<h2>Content Structure</h2>
 
<p>YouTubeSWEg is an attempt of replicating IMDB in the domain of YouTube content. While the main content of YouTube is multimedia videos, a lot of other content forms the building blocks of YouTube’s structure including channels, playlists, and categories. These components intermingle and are heavily related to each other, and content in one portion can directly and indirectly lead you to content in other portions. Because of this, we chose Videos, Channels, Playlists, and Categories as our four models. Each model contains five chosen attributes. These attributes represent, as they suggest, attributes about each model. The attributes are:
<br />
<br />
Videos – Title, Channel, Description, Thumbnail, Associated Tags, Categories
<br />
Channels – Title, description, date of publication, associated country, related playlists, view count, subscriber count
<br />
Categories – Title, latest published video date, number of videos, assignable, most popular videos from this category, most popular channels uploading to this category
<br />
Playlists – Title, description, associated tags, date of publication, item count
<br />
<br />
 
Each model links to at least two other models. Defining the relationship between models played an important role in the website design later on. The relationships are:
<br />
<br />
Videos link to Channels, Categories
<br />
Channels link to Videos, Playlists
<br />
Categories link to Videos, Channels
<br />
Playlists link to Channels, Videos 
<br />
<br />

The purpose of YouTubeSWEg is to provide very easy access to this information. </p>

<a name="WebsiteDesign"></a>
<h2>Website Design</h2>
 
<p>YouTubeSWEg places the greatest importance on the immersive experience of the user which does not compromise on ease of use. The design is heavily inspired by YouTube’s design and color palette.</p>

<p>It features a navbar on the top of the page that allows for easy navigation and lets you know what page you are currently on. The Navbar links to the following pages:
<br />
<br />
YouTubeSWEg Home page which features a carousel of pictures related to pages
<br />
Videos page containing a table of videos and their associated attributes
<br />
Channels page containing a table of channels and their associated attributes
<br />
Categories page containing a table of categories and their associated attributes
<br />
Playlists page containing a table of playlists and their associated attributes
<br />
About page featuring information about the creators of YouTubeSWEg and other relevant data to the project
<br />
<br />
Each page also features several clickable elements that cause new pages for each individual video, channel, playlist and category to be dynamically rendered by Flask and Jinja. For the rendered video pages the embedded YouTube video is present. The rendered channel, playlist and category pages also contain tables with links to the videos, channels etc. that they contain.</p>

<p>With the use of Bootstap, YouTubeSWEg works on multiple platforms including mobile devices with no issues and without compromising on user experience. Bootstrap is an HTML, CSS, and JS framework that incorporates responsive and dynamic design that is easy to use and build upon. It provides the tools to create a clean user interface with its pre-stylized elements. The API consists of many predefined templates needed to complete our web app, i.e. the navigation bar and carousel. These predefined templates are easy customize, saving us lot of time that may have otherwise been spent creating basic CSS files and HTML components. The collapsable navigation bar featured on YouTubeSWEg is able to adapt to smaller screens size by placing the tabs into a dropdown menu.</p>

<p>On the instances of our models, we take advantage of Bootstrap’s flexbox grid system, that adjusts the pages’ layout according to the size of the user’s device. This system makes the issue of spacing elements in a web page simple to tackle by dividing each page into a number of columns. Elements of the webpage can be placed into these predefined columns. Although this grid system is used throughout Bootstrap to make it responsive to different screen sizes, we only manually place elements using these columns to format side by side tables in the model of a category instance and in the model a channel instance.</p>

<p>Javascript is used to have our web page interact with user input. During this phase of the project, most of our JS use is to highlight the active tab of the navigation bar. At this point, we have the code for our navigation bar in a JS file, which is called by each of the pages to be displayed. Each page also removes the current active tab of the navigation bar and sets the appropriate tab to active.</p>

<a name="React"></a>
<h2>React</h2>

<p>React is an open-source JavaScript framework for building user interfaces. React allows webpages that use data to change over time without reloading the page. This corresponds to "View" in the Model-View-Controller template. YouTubeSweg uses react to create webpages that are dynamically rendered on the client side. This lets the user filter and search for particular elements that has already been loaded onto the client computer. On activating one of the several elements available including pagination, we trigger an http call to the backend that adds behaviour to our webpage. It also allows for real time rendering of webpages without the need of several static webpages. This makes our webpage more interactive and media rich. In future versions of YouTubeSweg we plan to make greater use of React to provide a more aesthetically pleasing experience. Integrating React into our initially static application was a struggle in the beginning due to the somewhat steep learning curve of the library and JavaScript and the difficultlies of debugging React code. However, as we picked up experience with React, we found that it was a very useful tool capable of creating web pages far smoother and more aesthetic than the static pages we had before. At this point, we feel rather confident that there are few people outside our group cabable of creating interactive and engaging UIs. Additionally, the cleanliness and modularity of the React code was a welcome sight after we spent as much time as we did making long, and admittedly ugly, HTML files with Jinja. Jinja still plays a significant part in our now immersive and dynamic application as we talk about a little later in this report, but there is no denying that the React code has taken our application to the next level. One huge issue that we ran into wth React was due to the asyncronous nature of the execution path of the code. We found ourselves using variables that intuitively should have already been set by the lines above it, but were somehow not initialized yet. Despite these issues, there is absolutely no denying the impact that React has made on the website we were able to deploy. Rendering our grid and buttons in React opened up many doors into what we were able to do and change with little pain once the initial torture was through. To be quite honest, we are still very unsure about why some of our code works in its current state but fails without some lines that seem completely irrelevant to the project.</p>

<p>React's API can be found here: <a href="https://facebook.github.io/react/docs/react-api.html">https://facebook.github.io/react/docs/react-api.html</a></p>
<p>A very useful tutorial to react can be found here: <a href="https://facebook.github.io/react/tutorial/tutorial.html">https://facebook.github.io/react/tutorial/tutorial.html</a></p>

<p>React allows YouTubeSweg to be far more responsive than a webpage that always required http requests for all user interactions with the webpage</p>

<br />
<br />

<a name="Backend"></a>
<h1>Backend</h1>

<p>The backend portion of our website is built upon a variety of different tools including the Google Cloud Platform for hosting the backend server, Flask for rendering HTML templates, and Jinja2 for the  engineering of static and dynamic templates. With the strategic use of Jinja2, we are able to effectively reuse HTML templates for the multiple models present in the website.</p>
<a name="YouTubeDataAPI"></a>
<h2>YouTube Data API</h2>

<p>As the title of the project suggests, we are utilizing the YouTube Data API to collect information. We are collecting information regarding Videos, Channels, Categories, and Playlists. There are several different endpoints present in the YouTube Data API to expose this data. By providing things like category ID’s, video ID’s, region codes, and more, we can find relevant YouTube videos in various scopes. One of the issues we faced was regarding the lack of uniformity among our the objects of our model. The attribute values of our channels for example vary significantly, with some channels not having and subscribers at all or videos with no tags. Despite the occasional inconsistency in the results from our API calls, we were able to put together a very rich database of models and populate a database hosted on GCP with very little trouble. We created a script to create JSON objects from the YouTube API responses, and then we created another to load the database tables with our data. </p>

<p>The reference for the YouTube Data API can be found here: <a href="https://developers.google.com/youtube/v3/docs/">https://developers.google.com/youtube/v3/docs/</a></p>
<a name="GCP"></a>
<h2>GCP</h2>
 
<p>YouTubeSWEg uses Google Cloud Platform to host our website. Google Cloud Platform is a cloud computing service by Google that offers hosting on the same supporting infrastructure that Google uses internally for end-user products like Google Search and YouTube. Cloud Platform provides developer products to build a range of programs from simple websites to complex applications. GCP was chosen over AWS due to its ease of use when deploying basic Python 3.5 applications that run on the Google App Engine Standard Environment. Google App Engine (often referred to as GAE or simply App Engine) is a cloud computing platform for developing and hosting web applications in Google-managed data centers. Applications are sandboxed and run across multiple servers. App Engine offers automatic scaling for web applications—as the number of requests increases for an application, App Engine automatically allocates more resources for the web application to handle the additional demand.</p>

<p>In the current version of the project the appengine_config.py in the root of the flask-app directory contains some basic configuration settings. The libraries that we are using are placed in the lib folder as shown in the configuration.</p>

<p>The configuration file for the GAE is the app.yaml file which contains settings such as python version, API version, the path of the primary script we are running, and path of static data files.</p>

<p>The application is run by GCP through the main.py file.</p>
<a name="InstallingTheGoogleCloudSDK"></a>
<h3>Installing the Google Cloud SDK</h3>

<p>In order to use the Google Cloud Platform, the Google Cloud SDK must be installed. The download can be found here: <a href="https://cloud.google.com/sdk/docs/">https://cloud.google.com/sdk/docs/</a></p>

<p>The SDK tools can then be added to the path through the following command:</p>

<p style="padding-left: 1.8em"><b>./google-cloud-sdk/install.sh</b></p>

<p>Then run gcloud init to initialize the SDK:</p>

<p style="padding-left: 1.8em"><b>gcloud init</b></p>

<p>Note: If the SDK tools are not added to the path, make sure to use the full path of the files in the SDK in all gcloud commands. i.e.  ./google-cloud-sdk/bin/gcloud</p>

<a name="DeployingYourApplication"></a>
<h3>Deploying your application</h3>
<p>To upload the app, run the following command from within the root directory of your project where the app.yaml file is located:</p>
<p style="padding-left: 1.8em"><b>gcloud app deploy</b></p>
<a name="DeployingYourApplicationLocally"></a>
<h3>Deploying your application locally</h3>
<p>In order to deploy the application locally, run:</p>
  <p style="padding-left: 1.8em"><b>python main.py</b></p>

<p>When running the application locally, it is important that the following is added to main.py</p>
<p style="padding-left: 1.8em"><b>if __name__ == '__main__':</b></p>
<p style="padding-left: 3.6em"><b>app.run(host='127.0.0.1', port=8080, debug=True)</b></p>

<p>This is needed in order to keep the server listening on the local host through port 8080. Deploying the application locally was essential in reducing debugging and testing time since it allowed us to almost instantaneously view the website after each change. Furthermore, no additional restarts were required after every change since the local changes would immediately reflect on the page. This would simply not be possible if a push to the cloud was done after each change.</p>
<a name="ViewingYourApplication"></a>
<h3>Viewing your application</h3>
<p>To launch your browser and view the app at http://[YOUR_PROJECT_ID].appspot.com, run the following command:</p> 
<p style="padding-left: 1.8em"><b>gcloud app browse</b></p>

<a name="PostgreSQLOnGCE"></a>
<h3>Setting up PostgreSQL</h3>

<p>YouTubeSWEg uses a PostgreSQL on a Google Compute Engine instance within our already existing Google Cloud Platform project that hosts our website to host the YouTubeSWEg database. When creating the database, the first thing you need to do is create a Compute Engine instance within a Google Cloud Platform project. Google Cloud Platform uses projects to manage resources, so any instance must be inside a project. The Compute Engine instance is essentially a virtual machine instance running Ubuntu with a persistent disk. Then, you can SSH into the instance and run the following commands to update the apt-get list of packages and Install PostgreSQL, including the PSQL client and server instrumentation, respectively:
</p>

<p style="padding-left: 1.8em"><b>sudo apt-get update
sudo apt-get -y install postgresql postgresql-client postgresql-contrib
</b></p>

<p>From there you use PSQL to complete setup. PostgreSQL will have created a default user named “postgres” during installation, but you will need to set a password to this user.
Run the root shell in the SSH terminal with:
</p>

<p style="padding-left: 1.8em"><b>sudo -s</b></p>

<p>Now run PSQL as “postgres”

We encountered some difficulties while setting up the configuration for remote access to PostgreSQL. The GCP website has additional information regarding solving this issue and can be found here: <a href="https://cloud.google.com/community/tutorials/setting-up-postgres">https://cloud.google.com/community/tutorials/setting-up-postgres</a></p>
</p>



<a name="Flask/Jinja2"></a>
<h2>Flask/Jinja2</h2>
<p>GCP not only allows our app to be hosted on the cloud, but it also hosts the code that handles RESTful API requests to our website and the actual location in which our database was hosted. When the backend code, that is the code that handles requests to our website, did not exist, though, we were using Flask and Jinja2 to serve up pages that were static but stellar and shallow but shining.</p>

<p>The heart of our website is in our main.py file, a python file that uses Flask to render HTML templates when the app route is changed. These functions then either use HTML pages that use React to dynamically load and display data on the client side or static HTML pages when loading a specific model instance. By default, Flask leverages Jinja2 as a template engine, so we used it to form finished web pages of our individual instances from our HTML templates using the data we passed it. As a full featured template engine, specifically built for use with Python, Jinja2 has full unicode support, an optional integrated sandboxed execution environment, is widely used and BSD licensed. We did not fully explore all the more intricate features of the tool, but we found that it fit our needs very adequately. Jinja2 allowed us to iterate through the data we provided with extreme ease and perform different actions based on the data provided (e.g. if we were passing a thumbnail image for a YouTube video, we displayed the thumbnail, if we passed a tuple of text and a route to another part of our site, we hyperlinked the the text to the provided route). This allowed us to limit the number of html templates we had to create. We only created a template for the model page and additional templates for each model instance type. One jinja2 feature that we found extremely helpful was the debugging system it provided. Jinja2 in union with Flask is able to integrate template compilation and runtime errors directly into the Python traceback system. Whenever we came across issues with our Jinja2 template, they were made very easy to find due to this fantastic system of displaying the exception traceback. </p>

<p>Flask made running and testing our website very simple. Testing our application locally consisted of simply running our main.py file after installing and importing Flask and setting the app to run at localhost:8080. We were then able to run and debug our code locally, seeing changes and, when they arose, exception tracebacks basically instantaneously. Flask made setting endpoints and behavior at those endpoints very easy, by simply adding @app.route(&lt;endpoint&gt;) before a python function to define the behavior of the app at that endpoint. Previously, our main.py was basically holding each of our relations in global data structures, which we pass to the Jinja2 templates with render_template. Though this excessive use of global variables was slightly shy of optimal, we thought it is more than adequate for holding and passing the data for the 12 model instances that we had at the time. </p>

<p>Now that we have an implementation for our API, however, we are better able to package and send the data that we scraped from the YouTube API, loaded into JSONS, and then stuffed into tables. Jinja2 does not have anything to do with this process, unfortunately, but Flask still plays a very large part in this process. As we mentioned earlier, Flask allows us to set endpoints for our website to set what we display throughout the site. In addition, however, those endpoints can be used to set endpoints for calls to our API. Rather then returning render_template([an HTML file]), we can return an object from the function which can then be used by our frontend or by any one of the millions of anxious developers who have been waiting for an open API from YouTubeSWEg. We have already discussed how we make our API calls from the frontend earlier in this report, and there is a link to our Apiary documentation elsewhere in this report, so if you'd like to learn more about our API, feel free to check it out or read the section in this report where we talk about it in more detail.</p>
<a name="SQLAlchemy"></a>

<h2>SQLAlchemy</h2>

<p>The backend models that our database will be based on was created using SQLAlchemy. Using the framework, we were able to relatively easily define the attributes and characteristics of each of the models through Python classes. We were also able to define relationships between the different models through the designated syntax. This was done through defining relation tables and invoking the relationship() method within each of the classes as needed. Some of the relations required a one-to-many relationship while others required a one-to-one relationship and yet others required a many-to-many relationship. This was all again handled quite simply through the SQLAlchemy syntax of defining relationships. Once we loaded the database with their attributes and relationships to each other, we were able to simply add the relevant attributes of the connected models into JSONs to send to our frontend (or one of our many API users). For example, when creating the JSON for Videos, the id's and titles for the channel and playlist that contain the video were also added to the JSON.</p>
<br />
<br />
<a name="Testing"></a>

<h1>Testing</h1>
<a name="ContinuousIntegration"></a>

<h2>Continuous Integration</h2>

<p>The YouTubeSWEg project is automatically linked to Travis CI through github, and though originally it was not running any additional tests after the end of the first phase, we know have extensive unit tests running to ensure the integrity of our project is maintained throughout the lifetime of the project. Ideally, a commit should successfully build on Travis before being merged into the default branch of your source control. For those of y'all that are unaware, Travis CI is a hosted, distributed continuous integration service used to build and test software projects hosted at GitHub. The configuration file is a hidden file in the root directory named .travis.yml which defines environment settings, set up scripts, and a test script to run against your code. For this purpose, it is usually easiest to use a makefile to trigger the build and run of a series of unit tests. Travis CI is automatically run whenever a change has been made to the github project. Continuous integration is the practice of merging all developer copies to a shared mainline several times a day. If you are unfamiliar with Travis CI but are interested in giving it a look on your next project, click <a href="https://docs.travis-ci.com/user/for-beginners">here</a> to checkout a tutorial.</p>
<a name="UnitTests"></a>

<h2>Unit Tests</h2>

<p>As Software Engineering Students we understand the importance of extensive testing of various modules of software. There are several extensive unit tests for the purpose of ensuring the accuracy and integrity of our backend database models. We ensure that in every potential situation that we were able to foresee, we have tests prepared to assure ourselves that any changes we make to a function do not affect the desired output of the program. There are a total of 15 unit tests spanning the 4 different models present in the application. Each model is tested to ensure that the attributes of the model are present in the expected way. Furthermore, the number of instances of each model that are present in the database are also verified.</p>

<br />
<br />
<a name="ApplicationProgrammingInterface(API)"></a>

<h1>Application Programming Interface (API)</h1>

<p>We have designed an API to expose the data that we are presenting on the website. The API presents various data regarding each of the specific models. The API can be used to retrieve data regarding videos, channels, categories, and playlists. Furthermore, there are multiple additional parameters for each of the endpoints so that more specific data can be retrieved. For example, in the videos endpoint of the API, there are optional parameters for ID, Channel ID, and Category ID. If these parameters are provided, only videos that are linked to those ID’s are returned in the response. Since videos are directly linked to channels and categories in our database itself, this is an accurate representation of how we are presenting the data on the website. The other models presented in the API also follow a similar pattern of optional parameters to narrow down the response in various ways. In our project, we make calls to our resources by using the jQuery get request $.getJSON([endpoint]), which then allows us to parse the resulting object in our React code. If you're interested in checking out how our API works, please don't hesitate to visit our Apiary, the link to which can be found below.</p>

<p>The YouTubeSWEg API can be found here: <a href="http://docs.youtubesweg.apiary.io/#">http://docs.youtubesweg.apiary.io/#</a></p>
<br />
<br />
<a name="UMLDiagram"></a>

<h1>UML Diagram</h1>

<p>We have prepared a UML diagram of our models in order to lay out the general behavior of each of our models and their interactions with each other. Each model is drawn with their respective attributes, and each of the models have an arrow with cardinalities to represent the relationships between the models. For example, Channel is pointed to by all three of the other models, Video, Playlist, and Category, because each of these point to an instance or instances of Channel. The UML diagram can be found in the Github Repository <a href="https://github.com/rayiniv/idb/blob/master/IDB1.pdf">here</a> along with other metadata and additional information about the YouTubeSweg Project.</p>
<br />
<br />

<a name="Search Bar"></a>

<h1>Search Bar</h1>

<p>We continued using React to implement the search feature in our website. After the user types in a word or a series of words into our search bar, they will be redirected to a page that pulls up all videos, channels, playlists, and/or categories in our database that contain the queried word(s). React receives a list of dictionaries to display with the results of the search and dynamically displays the results in grid form. Along with the dictionaries, the React code also receives the number of pages for the pagination to display and the search query. Our page uses this information to dynamically create pagination with the correct number of pages. Each list received has the set length of results to show on each page, in our case this number is 12. When the nth page is clicked, React asks the backend for the appropriate list of dictionaries that corresponds to the nth page, which React then displays. The list of dictionaries that react receives from flask has &#60mark&#62 tags surrounding the appropriate queried words. In order to have the HTML correctly display these tags and highlight the queried words, Jinja2 is turned off during these methods using escape tags, raw and endraw. There is an attribute set in the HTML that allows React to properly display the string (with the HTML tags included) properly when the page is rendered.

Much like our sort and filter methods, once the user hits the "Go!" button on the search bar, the frontend will make a call to Flask to redirect to the new page with the appropriate objects. The frontend will send in the query to the backend during this call. The backend then handles creating the results. It sifts through the database for results that match the searched words. In order to display results with all words searched first, we create separate lists of dictionaries that each hold the results that contain a specific number of words matched from the query. The final list of dictionaries that will be rendered on the search results page will be combined from two dictionaries (one with results containing all search terms and one with results containing at least one search term) built from the four resources (video, channel, playlist, and category).

We decided on adding a nice feature that was missing from the initial implementation (when we simply copied the Bootstrap starter code for a search bar). Whenever a user has already typed in any sort of text in the text field, they can press the Enter key and complete the search request. This was accomplished using JavaScript that would attach a listener to the textbox and call the method representing the enter button (which makes an API call as well) and eventually creates a search request.</p>

<br />
<br />

<a name="PlanITPoker"></a>

<h1>PlanITPoker</h1>

<p>Our PlanITPoker contains ten user stories which helped us delegate tasks in an agile manner as if we were on Team Litty or a real world software development team. The time estimates aided in fairly distributing tasks to our fantastic teammates. Giving each team member a similar amount of work was essential to our success and satisfaction as a team. This tool kept us on track to effectively accomplish our goals and finish in a very timely manner without having any one teammate carrying the load. If we discovered that one task was longer or shorter than previously expected, we were able to pivot our assignments in an agile manner. This often times involved splitting a story into multiple, smaller stories. For example, we discovered that creating the visualization in D3 was a more time consuming task than originally estimated, so we then divided the task into 1) Parsing the data from Eklogi.me, the website we are visualizing and 2) Building the actual visualization of the data from step one.

Below are recounts of each story:
<br />
<p>1) Create a search bar. Purely front end work; the search bar does not need functionality yet.</p>
    <p style="padding-left: 1.8em">Expected time: 45 minutes</p>
    <p style="padding-left: 1.8em">Real time: 10 minutes</p>
<p>2) Implement back end search functionality. Return relevant results given a query.</p>
    <p style="padding-left: 1.8em">Expected time: 1 hr 30 minutes</p>
    <p style="padding-left: 1.8em">Real time: 2 hours</p>
<p>3) Create data visualization of the other group's data.</p>
    <p style="padding-left: 1.8em">Expected time: 1 hour</p>
    <p style="padding-left: 1.8em">Real time: 1 hour and 32 minutes</p>
<p>4) Parse data for visualization.</p>
    <p style="padding-left: 1.8em">Expected time: 45 minutes</p>
    <p style="padding-left: 1.8em">Real time: 45 minutes</p>
<p>5) Integrate data visualization into website.</p>
    <p style="padding-left: 1.8em">Expected time: 15 minutes</p>
    <p style="padding-left: 1.8em">Real time: 20 minutes</p>
<p>6) Create search results page.</p>
    <p style="padding-left: 1.8em">Expected time: 1 hour</p>
    <p style="padding-left: 1.8em">Real time: 50 minutes</p>
<p>7) Fix bug on search results page with results displaying strangely. Perhaps need to enforce minimum height.</p> 
    <p style="padding-left: 1.8em">Expected time: 15 minutes</p>
    <p style="padding-left: 1.8em">Real time: 10 minutes</p>
<p>8) Implement highlighting of search terms on search results page.</p>
    <p style="padding-left: 1.8em">Expected time: 45 minutes</p>
    <p style="padding-left: 1.8em">Real time: 2 hours</p>
<p>9) Parts of data visualization fly off the screen shortly after animation begins. Need to stay on page.</p> 
    <p style="padding-left: 1.8em">Expected time: 30 minutes</p>
    <p style="padding-left: 1.8em">Real time: 30 minutes</p>
<p>10) Extend technical report to reach 5,000 words.</p>
    <p style="padding-left: 1.8em">Expected time: 1 hour 30 minutes</p>
    <p style="padding-left: 1.8em">Real time: 1 hours 30 minutes</p></p>

<br />
<br />

<a name="Visualization"></a>

<h1>Visualization</h1>

<p>Youtubesweg.me provides a visualization of another CS373 IDB project. The visualization is dedicated to Group 8 - Eklogi.me. Eklogi.me features a variety of information regarding the political landscape in the US. Information regarding members of the United States House of Representatives, members of the United States Senate, committees in the House of Representatives and Senate, bills in the House of Representatives and Senate, and finally, votes on bills and actions in both the House of Representatives and Senate. We utilize all of this information on our visualization page. We acquire the data from Eklogi.me through their RESTful API. The API provides information on all of the resources mentioned above in JSON format. We make the REST API calls in our flask application and consolidate the data in a way that is visually informative. After making the RESTful API calls, we traversed each individual resource in order to scour for connections between the resources. We consolidated this information into a JSON file so that the data is usable on the JavaScript front end. Our JSON simply looks at the information in terms of objects (circles) and connections (lines). We represent these separately in two different dictionaries in our JSON. Our visualization presents the data mentioned through a plethora of connected spheres. Each sphere represents either a member of the House of Representatives or Senate, a committee, a bill, or a vote. The connections between the spheres represents a connection between those resources. The connections were formed by analyzing the data retrieved from the REST API. The circles present data to the user as the user hovers over the circles. The data presented is respective to the circle itself, i.e. the object presented is different depending on the object the circle is representing. The circles are color coded so that the user can more easily see the different types of objects. The members are presented in blue, the committees are represented in light blue, the bills are represented in orange, and the votes are represented in light orange. The visualization is also interactive in that the user can click and drag the circles in the visualization. This provides the ability to focus in on certain objects and their respective connections. An interesting effect that is seen in the visualization is the presence of several members connected to one committee alone. This shows that there are several members of the house and senate that are solely dedicated to working on a single committee. Obviously, this is not the case for all the members of congress as there are several others that are present in multiple committees. Another interesting property is that the bubbles of members and committees split into two separate bubbles. This implies that there are two separate sets of committees, A and B, in which no inherent member is present in both sets A and B at the same time. This conclusion could not readily be arrived at without the visualization as the amount of data is tremendous.</p>

    </div> <!-- /container -->

</body>
</html>
